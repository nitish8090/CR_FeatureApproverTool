# -*- coding: utf-8 -*-
"""
/***************************************************************************
 sdafDockWidget
                                 A QGIS plugin
 sdf
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-10-19
        git sha              : $Format:%H$
        copyright            : (C) 2021 by dasf
        email                : adsf
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal, Qt

from PyQt5.QtCore import QVariant
from PyQt5.QtGui import QImage, QIcon, QPixmap, QPalette, QBrush, QColor, QFontDatabase, QFont

from qgis.core import QgsProject, QgsMapLayer, QgsField, edit, QgsPalLayerSettings, QgsTextFormat, \
    QgsVectorLayerSimpleLabeling, QgsTextBufferSettings
from qgis.utils import iface

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'cr_feature_approver_dockwidget_base.ui'))


class CRFeatureApproverDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(CRFeatureApproverDockWidget, self).__init__(parent)
        self.setupUi(self)

        self.selected_layer = None
        self.selected_feature = None

        # UI Conncetions
        # self.combobox_layers
        self.cbox_roof_t.addItems(['Flat', 'Gable', 'Mix', 'Hip', 'Other'])
        self.cbox_roof_c.addItems(['Good', 'Fair', 'Bad', 'Damaged'])
        self.cbox_roof_m.addItems(['Asphalt', 'Tile', 'Shingle', 'Metal', 'Other'])

        # self.cbox_roof_t.currentTextChanged.connect(self.check_is_dirty)
        # self.cbox_roof_c.currentTextChanged.connect(self.check_is_dirty)
        # self.cbox_roof_m.currentTextChanged.connect(self.check_is_dirty)

        # Button Connections
        self.btn_refresh_layer.clicked.connect(self.refresh_layer_list)
        self.btn_select_layer.clicked.connect(self.select_layer)

        self.btn_next.clicked.connect(self.next)
        self.btn_previous.clicked.connect(self.previous)
        self.btn_approve_next.clicked.connect(self.approve_and_next)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def refresh_layer_list(self):
        """ Update the layer list in combo box"""
        print("Refreshing Layer List")

        self.combobox_layers.clear()
        for layer in QgsProject.instance().mapLayers().values():
            layer_name = layer.name()
            if layer.type() == QgsMapLayer.VectorLayer:
                self.combobox_layers.addItem(layer_name)
                print(f"{layer_name} | Added to combo box")

    def select_layer(self):
        """ Select the layer and start the work"""
        print("Selecting Layer")

        content = self.combobox_layers.currentText()
        layers = QgsProject.instance().mapLayersByName(content)
        if len(layers) > 1:
            print(f"[WARNING] More than one layer with name {content}")

        self.selected_layer = SelectedLayer(layers[0])
        self.selected_layer.enable_labels()
        self.selected_layer.validate()
        self.selected_layer.read_indexes()

        # Disable layer selection buttons
        self.btn_select_layer.setEnabled(False)
        self.btn_refresh_layer.setEnabled(False)
        self.combobox_layers.setEnabled(False)

        # Enable approver buttons
        self.btn_next.setEnabled(True)
        # self.btn_previous.setEnabled(True)
        self.btn_approve_next.setEnabled(True)

        self.selected_feature = self.selected_layer.get_next_feature()
        zoom_to_a_feature(self.selected_feature)

    def next(self):
        self.skip_feature(self.selected_feature)

        self.selected_feature = self.selected_layer.get_next_feature()
        zoom_to_a_feature(self.selected_feature)
        self.update_combo_boxes(self.selected_feature)

    def previous(self):
        pass

    def approve_and_next(self):
        # new_value = 'True'
        # with edit(self.selected_layer.layer):
        #     print("Verifying feature")
        #     self.selected_layer.layer.changeAttributeValue(self.selected_feature.id(),
        #                                                    self.selected_layer.index_of_verified, new_value)
        #
        # self.selected_feature = self.selected_layer.get_next_feature()
        # zoom_to_a_feature(self.selected_feature)
        # self.update_combo_boxes(self.selected_feature)

        self.update_feature(self.selected_feature)

        self.selected_feature = self.selected_layer.get_next_feature()
        zoom_to_a_feature(self.selected_feature)
        self.update_combo_boxes(self.selected_feature)

    def update_combo_boxes(self, feature):

        # self.selected_layer.index_roof_t
        # self.selected_layer.index_roof_c
        # self.selected_layer.index_roof_m

        roof_type = feature.attributes()[self.selected_layer.index_roof_t]
        roof_condition = feature.attributes()[self.selected_layer.index_roof_c]
        roof_material = feature.attributes()[self.selected_layer.index_roof_m]
        print(roof_type, roof_condition, roof_material)

        roof_type_index = self.cbox_roof_t.findText(roof_type, Qt.MatchContains)
        self.cbox_roof_t.setCurrentIndex(roof_type_index)

        roof_condition_index = self.cbox_roof_c.findText(roof_condition, Qt.MatchContains)
        self.cbox_roof_c.setCurrentIndex(roof_condition_index)

        roof_material_index = self.cbox_roof_m.findText(roof_material, Qt.MatchContains)
        self.cbox_roof_m.setCurrentIndex(roof_material_index)
        print(roof_type_index, roof_condition_index, roof_material_index)

    def update_feature(self, feature):
        roof_type = feature.attributes()[self.selected_layer.index_roof_t]
        roof_condition = feature.attributes()[self.selected_layer.index_roof_c]
        roof_material = feature.attributes()[self.selected_layer.index_roof_m]
        #
        # roof_type_index = self.cbox_roof_t.findText(roof_type, Qt.MatchContains)
        # self.cbox_roof_t.setCurrentIndex(roof_type_index)

        # roof_condition_index = self.cbox_roof_t.findText(roof_condition, Qt.MatchContains)
        current_roof_type = self.cbox_roof_t.currentText()
        current_roof_condition = self.cbox_roof_c.currentText()
        current_roof_material = self.cbox_roof_m.currentText()

        is_dirty = False

        if roof_type != current_roof_type or roof_material != current_roof_material or roof_condition != current_roof_condition:
            is_dirty = True
            print('is dirty true')

        if is_dirty:
            with edit(self.selected_layer.layer):
                print("Editing feature")

                self.selected_layer.layer.changeAttributeValue(feature.id(),
                                                               self.selected_layer.index_roof_t, current_roof_type)
                self.selected_layer.layer.changeAttributeValue(feature.id(),
                                                               self.selected_layer.index_roof_c, current_roof_condition)
                self.selected_layer.layer.changeAttributeValue(feature.id(),
                                                               self.selected_layer.index_roof_m, current_roof_material)

                self.selected_layer.layer.changeAttributeValue(feature.id(),
                                                               self.selected_layer.index_of_cc_status, 'Corrected')

                # self.selected_layer.layer.changeAttributeValue(feature.id(),
                #                                                self.selected_layer.index_of_modified, 'True')

        else:
            with edit(self.selected_layer.layer):
                print("Verifying feature")
                self.selected_layer.layer.changeAttributeValue(feature.id(),
                                                               self.selected_layer.index_of_cc_status, 'Verified')

        print("test end")

        # roof_material_index = self.cbox_roof_t.findText(roof_material, Qt.MatchContains)
        # self.cbox_roof_m.setCurrentIndex(roof_material_index)

    # def check_is_dirty(self):
    #     print("Dirty True")

    def skip_feature(self, feature):
        with edit(self.selected_layer.layer):
            print("Verifying feature")
            self.selected_layer.layer.changeAttributeValue(feature.id(),
                                                           self.selected_layer.index_of_cc_status, 'Skipped')


class SelectedLayer:

    def __init__(self, layer):
        self.layer = layer

        self._field_names = None

        self.features = self.layer.getFeatures(""" "cc_status" IS NULL """)

        # self.index_of_verified = None
        # self.index_of_modified = None
        # self.index_of_modifiedby = None
        # self.index_of_skipped = None
        self.index_of_cc_status = None

        self.index_roof_t = None
        self.index_roof_c = None
        self.index_roof_m = None

    @property
    def field_names(self):
        if self._field_names is None:
            self._field_names = [field.name() for field in self.layer.fields()]
        return self._field_names

    def validate(self):
        # Get Layer provider
        layer_provider = self.layer.dataProvider()

        # Add validation fields if not present
        # valid_fields = ['verified', 'modified', 'modifiedby', 'skipped']
        valid_fields = ['cc_status']
        for valid_field in valid_fields:
            if valid_field not in self.field_names:
                print(f"{valid_field} not found in {self.field_names} | Adding")

                layer_provider.addAttributes([QgsField(valid_field, QVariant.String)])

        self.layer.updateFields()

    def read_indexes(self):
        self.index_roof_t = self.layer.fields().indexOf('Roof_T')
        self.index_roof_c = self.layer.fields().indexOf('Roof_C')
        self.index_roof_m = self.layer.fields().indexOf('Roof_M')

        self.index_of_cc_status = self.layer.fields().indexOf('cc_status')

        # self.index_of_verified = self.layer.fields().indexOf('verified')
        # self.index_of_modified = self.layer.fields().indexOf('modified')
        # self.index_of_modifiedby = self.layer.fields().indexOf('modifiedby')
        # self.index_of_skipped = self.layer.fields().indexOf('skipped')

    def get_next_feature(self):
        feature = next(self.features)
        return feature

    def enable_labels(self):
        layer_settings = QgsPalLayerSettings()
        # text_format = QgsTextFormat()
        #
        # text_format.setFont(QFont("Arial", 12))
        # text_format.setSize(12)
        #
        # buffer_settings = QgsTextBufferSettings()
        # buffer_settings.setEnabled(True)
        # buffer_settings.setSize(1)
        # buffer_settings.setColor(QColor("white"))
        #
        # text_format.setBuffer(buffer_settings)
        # layer_settings.setFormat(text_format)

        layer_settings.fieldName = """ concat("Roof_T" , ', ' , "Roof_C",  ', ', "Roof_M") """
        layer_settings.isExpression = True
        # layer_settings.placement = 2

        layer_settings.enabled = True

        layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
        self.layer.setLabelsEnabled(True)
        self.layer.setLabeling(layer_settings)
        self.layer.triggerRepaint()


def zoom_to_a_feature(feature):
    canvas = iface.mapCanvas()

    bbox = feature.geometry().buffer(10, -1).boundingBox()
    print(bbox)

    canvas.setExtent(bbox)
    # canvas.zoomScale(850)
    canvas.refresh()
